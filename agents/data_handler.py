import logging
from typing import Dict, Any,List
from langchain_ollama import OllamaLLM
from agents.query_runner import QueryRunner
import json
from datetime import datetime
import sys
import os

# Get the backend path
backend_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', 'backend'))
if backend_path not in sys.path:
    sys.path.insert(0, backend_path)

try:
    try:
        from backend.core.config import settings  # Try importing from backend/config.py
    except ImportError:
        # Fallback: use environment variables directly
        from dotenv import load_dotenv

        # Load from backend/.env
        env_path = os.path.join(backend_path, '.env')
        load_dotenv(env_path)

        #simple settings
        class BackendEnvSettings:
            def __init__(self):
                self.DATABASE_URL = os.getenv("DATABASE_URL")
                self.LLM_MODEL = os.getenv("LLM_MODEL", "default-model")
        settings = BackendEnvSettings()
except ImportError:
    from dotenv import load_dotenv

    env_path = os.path.join(backend_path, '.env')
    load_dotenv(env_path)

    # Create simple settings
    class FallbackEnvSettings:
        DATABASE_URL = os.getenv("DATABASE_URL")
        LLM_MODEL = os.getenv("LLM_MODEL", "default-model")

    settings = FallbackEnvSettings()


backend_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
if backend_path not in sys.path:
    sys.path.insert(0, backend_path)
try:
    from backend.core.config import settings
except ImportError as e:
    print(f"Warning: Could not import from backend/config.py: {e}")
    # Fallback to environment variables
    import os
    from dotenv import load_dotenv
    load_dotenv(os.path.join(backend_path, '.env'))
    class Settings:
        def __init__(self):
            self.DATABASE_URL = os.getenv("DATABASE_URL")
            self.LLM_MODEL = os.getenv("LLM_MODEL", "default-model")

    settings = Settings()

logger = logging.getLogger(__name__)

#tables the user is allowed to modify
ALLOWED_USER_MOD_TABLES = ['transactions','budgetentries']

class DataHandler:
    def __init__(self):
        # Handle different settings types
        llm_model = getattr(settings, 'LLM_MODEL', None) or os.getenv('LLM_MODEL', 'llama2')
        self.llm = OllamaLLM(model=llm_model)
        self.query_runner = QueryRunner()
        self.pending_deletes = {}  # Store pending delete operations: {user_id: {session_id: delete_info}}


    def process_natural_language_create(self, enhanced_query: str, original_user_query: str, user_id: int) -> Dict[str, Any]:
        """
        Process natural language to generate INSERT SQL statements
        """
        
        prompt = f"""
        Convert this user request into a PostgreSQL INSERT statement.
        
        USER REQUEST: "{original_user_query}"
        USER ID: {user_id}
        DATABASE SCHEMA:
        - transactions table: id (INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY), user_id (integer), category_id (integer), amount (numeric), created_at (timestamp)
        - budgetentries table: id (INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY), budget_id (integer), category_id (integer), planned (numeric), user_id (integer)
        - goals table: id (INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY), user_id (integer), name (text), type (text), target_amount (numeric), current_amount (numeric), status (text)

        IMPORTANT RULES:
        1. For INSERT statements, ONLY include columns that need values
        2. DO NOT include id column (it's SERIAL, auto-generated)
        3. DO NOT include created_at column (it has DEFAULT NOW())
        4. For transactions: only include user_id, category_id, amount
        5. Expense amounts are NEGATIVE: -75.00
        6. Income amounts are POSITIVE: 200.00

        CATEGORY ID MAPPING:
        - Dining Out / dinner / restaurant: category_id = 10
        - Groceries / food shopping: category_id = 4
        - Freelance income: category_id = 12
        - Salary income: category_id = 11
        - Rent: category_id = 2
        - Utilities: category_id = 3
        - Transportation: category_id = 5
        - Entertainment: category_id = 6
        - Healthcare: category_id = 7
        - Insurance: category_id = 8
        - Travel: category_id = 14
        - Education: category_id = 15

        EXAMPLES:
        User says: "log $75 dinner expense"
        SQL: INSERT INTO transactions (user_id, category_id, amount) VALUES ({user_id}, 10, -75.00)

        User says: "add $500 grocery budget"
        SQL: INSERT INTO budgetentries (user_id, category_id, planned) VALUES ({user_id}, 4, 500.00)

        User says: "record $200 freelance income"
        SQL: INSERT INTO transactions (user_id, category_id, amount) VALUES ({user_id}, 12, 200.00)

        User says: "set $5000 vacation savings goal"
        SQL: INSERT INTO goals (user_id, name, type, target_amount) VALUES ({user_id}, 'Vacation fund', 'savings', 5000.00)

        CRITICAL: Output ONLY the SQL statement, nothing else. No explanations, no markdown.

        Generate SQL for: "{original_user_query}"
        SQL:
        """

        try:
            sql_query = self.llm.invoke(prompt).strip()
            logger.info(f"Generated SQL: {sql_query}")
            
            # Clean up SQL
            sql_query = sql_query.replace('```sql', '').replace('```', '').strip()
            
            # Remove any quotes around SQL
            if sql_query.startswith('"') and sql_query.endswith('"'):
                sql_query = sql_query[1:-1]
            elif sql_query.startswith("'") and sql_query.endswith("'"):
                sql_query = sql_query[1:-1]
            
            # Validate INSERT statement
            if not sql_query.upper().startswith('INSERT INTO'):
                raise ValueError("Must be an INSERT statement")
            
            # Check for forbidden columns
            if ' id,' in sql_query.lower() or '(id' in sql_query.lower():
                raise ValueError("Remove 'id' column - it's auto-generated")
            
            if 'created_at' in sql_query.lower():
                raise ValueError("Remove 'created_at' column - it's auto-generated")
            
            # Check user_id is included
            if str(user_id) not in sql_query:
                raise ValueError(f"Must include user_id = {user_id}")
            
            # Validate table is allowed
            import re
            table_match = re.search(r'INSERT INTO\s+(\w+)', sql_query, re.IGNORECASE)
            if table_match:
                table_name = table_match.group(1).lower()
                if table_name not in ALLOWED_USER_MOD_TABLES:
                    raise ValueError(f"Cannot insert into table: {table_name}")
            
            # checks columns in transactions
            if 'transactions' in sql_query.lower():
                col_match = re.search(r'INSERT INTO transactions\s*\((.*?)\)', sql_query, re.IGNORECASE)
                if col_match:
                    columns = [col.strip().lower() for col in col_match.group(1).split(',')]
                    if 'id' in columns:
                        raise ValueError("Remove 'id' from transactions column list")
                    if 'created_at' in columns:
                        raise ValueError("Remove 'created_at' from transactions column list")
                    
                    expected = ['user_id', 'category_id', 'amount']
                    for col in expected:
                        if col not in columns:
                            raise ValueError(f"Transactions INSERT must include: {col}")
            
            # execute SQL
            try:
                result = self.query_runner.execute_query(sql_query)
                logger.info(f"SQL executed successfully: {result.get('message', '')}")
                
                # Log interaction
                self.log_interaction(
                    user_id=user_id,
                    original_prompt=original_user_query,
                    response=f"Executed: {sql_query}"
                )
                
                return {
                    "status": "COMPLETE",
                    "sql": sql_query,
                    "message": f"Record added successfully. {result.get('rowcount', 0)} rows affected."
                }
                
            except Exception as exec_error:
                logger.error(f"SQL execution failed: {exec_error}")
                return {
                    "status": "ERROR",
                    "sql": sql_query,
                    "message": f"Failed to execute: {str(exec_error)}"
                }
                
        except Exception as e:
            logger.error(f"CREATE processing failed: {e}")
            return {
                "status": "ERROR",
                "sql": None,
                "message": f"Failed to process request: {str(e)}"
            }

    def process_natural_language_update(self, enhanced_query: str, original_user_query: str, user_id: int) -> Dict[str, Any]:
        """
        Process natural language to generate UPDATE SQL statements
        """
        prompt = f"""
        Convert this to a PostgreSQL UPDATE statement.

        USER: "{original_user_query}"
        USER_ID: {user_id}

        RULES:
        1. Start with UPDATE table_name
        2. Use SET column = value
        3. MUST include: WHERE user_id = {user_id}
        4. Output ONLY the SQL

        Example: "change grocery budget to $600" â†’ UPDATE budgetentries SET planned = 600.00 WHERE user_id = {user_id} AND category_id = 4

        Generate SQL for: "{original_user_query}"

        SQL:
        """

        try:
            sql_query = self.llm.invoke(prompt).strip()
            logger.info(f"Generated UPDATE SQL: {sql_query}")
            
            # Clean up
            sql_query = sql_query.replace('```sql', '').replace('```', '').strip()
            
            if not sql_query.upper().startswith('UPDATE'):
                raise ValueError("Must be UPDATE statement")
            
            if f"WHERE user_id = {user_id}" not in sql_query.upper():
                raise ValueError(f"Must include WHERE user_id = {user_id}")
            
            return {
                "status": "COMPLETE",
                "sql": sql_query,
                "message": f"SQL generated successfully"
            }

        except Exception as e:
            logger.error(f"UPDATE processing failed: {e}")
            return {
                "status": "ERROR",
                "sql": None,
                "message": f"Failed to process update request: {str(e)}"
            }

    def process_natural_language_delete(self, enhanced_query: str, original_user_query: str, user_id: int, session_id: str = '') -> Dict[str, Any]:
        """
        Process natural language to generate DELETE SQL statements
        Focus on transaction deletions with strict safety measures
        """
        prompt = f"""
        Convert this user request into a PostgreSQL DELETE statement.

        USER REQUEST: "{original_user_query}"
        USER ID: {user_id}
        
        DATABASE SCHEMA:
        - transactions table: id (INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY), user_id (integer), category_id (integer), amount (numeric), created_at (timestamp)
        
        IMPORTANT SAFETY RULES:
        1. ONLY allow DELETE FROM transactions table
        2. MUST include WHERE user_id = {user_id} to ensure user only deletes their own data
        3. For deleting specific transactions, include transaction ID if mentioned
        4. For deleting by date, use DATE(created_at) = 'YYYY-MM-DD'
        5. For deleting by category, include category_id condition
        6. ALWAYS use LIMIT 1 when deleting single records mentioned in natural language
        7. Be specific - don't delete all records unless explicitly requested
        
        CATEGORY ID MAPPING:
        - Dining Out / dinner / restaurant: category_id = 10
        - Groceries / food shopping: category_id = 4
        - Freelance income: category_id = 12
        - Salary income: category_id = 11
        - Rent: category_id = 2
        - Utilities: category_id = 3
        - Transportation: category_id = 5
        - Entertainment: category_id = 6
        - Healthcare: category_id = 7
        - Insurance: category_id = 8
        - Travel: category_id = 14
        - Education: category_id = 15

        EXAMPLES:
        User says: "delete my last transaction"
        SQL: DELETE FROM transactions WHERE id = (SELECT id FROM transactions ORDER BY created_at DESC LIMIT 1) and user_id = 1;
        
        User says: "remove the dinner expense from yesterday"
        SQL: DELETE FROM transactions WHERE user_id = {user_id} AND category_id = 10 -- Assuming 10 is the ID for 'dinner' AND created_at >= current_date - INTERVAL '1 day' AND created_at < current_date LIMIT 1;

        
        User says: "delete transaction with ID 5"
        SQL: DELETE FROM transactions WHERE user_id = {user_id} AND id = 5
        
        User says: "remove all grocery expenses from this month"
        SQL: DELETE FROM transactions WHERE user_id = {user_id} AND category_id = 4 AND EXTRACT(MONTH FROM created_at) = EXTRACT(MONTH FROM CURRENT_DATE) AND EXTRACT(YEAR FROM created_at) = EXTRACT(YEAR FROM CURRENT_DATE)
        
        User says: "delete the $75 expense I just added"
        SQL: DELETE FROM transactions WHERE user_id = {user_id} AND amount = -75.00 ORDER BY created_at DESC LIMIT 1
        
        CRITICAL: Output ONLY the SQL statement, nothing else. No explanations, no markdown.
        WARNING: Be extremely cautious with DELETE statements. Always include user_id constraint.

        Generate SQL for: "{original_user_query}"
        SQL:
        """

        try:
            sql_query = self.llm.invoke(prompt).strip()
            logger.info(f"Generated DELETE SQL: {sql_query}")
            
            # Clean SQL
            sql_query = sql_query.replace('```sql', '').replace('```', '').strip()
            
            # Remove quotes around SQL
            if sql_query.startswith('"') and sql_query.endswith('"'):
                sql_query = sql_query[1:-1]
            elif sql_query.startswith("'") and sql_query.endswith("'"):
                sql_query = sql_query[1:-1]
            
            # Validate DELETE statement
            if not sql_query.upper().startswith('DELETE FROM'):
                raise ValueError("Must be a DELETE FROM statement")
            
            # Check user_id is included
            if f"user_id = {user_id}" not in sql_query and f"user_id={user_id}" not in sql_query:
                # Also check for IN clause or other user_id references
                if f"WHERE user_id IN ({user_id}" not in sql_query:
                    raise ValueError(f"DELETE statement must include user_id = {user_id} for safety")
            
            # Validate table is allowed
            import re
            table_match = re.search(r'DELETE FROM\s+(\w+)', sql_query, re.IGNORECASE)
            if table_match:
                table_name = table_match.group(1).lower()
                if table_name != 'transactions':
                    raise ValueError(f"Cannot delete from table: {table_name}. Only 'transactions' table is allowed.")
            
            # generates preview of what will be deleted
            preview_info = self._preview_delete(sql_query, user_id)
            
            # generate unique confirmation ID
            import uuid
            confirmation_id = str(uuid.uuid4())[:8]
            
            # Store pending delete
            if user_id not in self.pending_deletes:
                self.pending_deletes[user_id] = {}
            
            self.pending_deletes[user_id][confirmation_id] = {
                'sql_query': sql_query,
                'original_query': original_user_query,
                'preview': preview_info,
                'created_at': datetime.now(),
                'session_id': session_id
            }
            
            # Clean up old pending deletes
            self._cleanup_old_pending_deletes()
            
            # Return confirmation request
            return {
                "status": "CONFIRM_REQUIRED",
                "confirmation_id": confirmation_id,
                "sql": sql_query,
                "preview": preview_info,
                "message": f"Delete operation requires confirmation. {preview_info['message']} Please confirm with 'yes' or 'confirm {confirmation_id}' to proceed, or 'no' to cancel."
            }
                
        except Exception as e:
            logger.error(f"DELETE processing failed: {e}")
            return {
                "status": "ERROR",
                "sql": None,
                "message": f"Failed to process delete request: {str(e)}"
            }
        
    def confirm_delete(self, user_id: int, confirmation_id: str, confirm: bool = True, session_id: str = '') -> Dict[str, Any]:
        """
        Confirm or cancel a pending delete operation
        
        Args:
            user_id: The user ID
            confirmation_id: The confirmation ID from the pending delete
            confirm: True to execute, False to cancel
            session_id: Optional session ID
            
        Returns:
            Dict with operation result
        """
        try:
            # Check if user has pending deletes
            if user_id not in self.pending_deletes or confirmation_id not in self.pending_deletes[user_id]:
                return {
                    "status": "ERROR",
                    "message": f"No pending delete found with confirmation ID: {confirmation_id}"
                }
            
            delete_info = self.pending_deletes[user_id][confirmation_id]
            sql_query = delete_info['sql_query']
            original_query = delete_info['original_query']
            
            if not confirm:
                # Cancel delete
                del self.pending_deletes[user_id][confirmation_id]
                
                # Log cancellation
                self.log_interaction(
                    user_id=user_id,
                    original_prompt=f"CANCELLED: {original_query}",
                    response=f"Cancelled delete with confirmation ID: {confirmation_id}"
                )
                
                return {
                    "status": "CANCELLED",
                    "message": "Delete operation cancelled.",
                    "confirmation_id": confirmation_id
                }
            
            # Execute delete
            try:
                result = self.query_runner.execute_query(sql_query)
                logger.info(f"DELETE executed successfully: {result.get('message', '')}")
                
                rowcount = result.get('rowcount', 0)
                
                # Log interaction
                self.log_interaction(
                    user_id=user_id,
                    original_prompt=original_query,
                    response=f"CONFIRMED and executed DELETE: {sql_query} (Deleted {rowcount} rows)"
                )
                
                # Clean up pending delete
                del self.pending_deletes[user_id][confirmation_id]
                
                if rowcount == 0:
                    message = "No records found to delete with the specified criteria."
                else:
                    message = f"Successfully deleted {rowcount} record(s)."
                
                return {
                    "status": "COMPLETE",
                    "sql": sql_query,
                    "message": message,
                    "rows_deleted": rowcount,
                    "confirmation_id": confirmation_id
                }
                
            except Exception as exec_error:
                logger.error(f"DELETE execution failed: {exec_error}")
                
                # Clean up pending delete even on error
                if confirmation_id in self.pending_deletes.get(user_id, {}):
                    del self.pending_deletes[user_id][confirmation_id]
                
                return {
                    "status": "ERROR",
                    "sql": sql_query,
                    "message": f"Failed to execute delete: {str(exec_error)}",
                    "confirmation_id": confirmation_id
                }
                
        except Exception as e:
            logger.error(f"Confirm delete failed: {e}")
            return {
                "status": "ERROR",
                "message": f"Failed to process confirmation: {str(e)}"
            }

    def _preview_delete(self, sql_query: str, user_id: int) -> Dict[str, Any]:
        """
        Preview what will be deleted by running a SELECT first
        
        Args:
            sql_query: The DELETE SQL query
            user_id: The user ID
            
        Returns:
            Dict with preview information
        """
        try:
            # Convert DELETE to SELECT for preview
            preview_sql = sql_query.replace('DELETE FROM', 'SELECT * FROM')
            
            count_sql = preview_sql
            if 'LIMIT' in count_sql.upper():
                count_sql = count_sql[:count_sql.upper().index('LIMIT')].strip()
            
            # Add COUNT for total
            count_sql = f"SELECT COUNT(*) as record_count FROM ({count_sql}) as subquery"
            
            # Execute preview queries
            preview_result = self.query_runner.execute_query(preview_sql)
            count_result = self.query_runner.execute_query(count_sql)
            
            record_count = count_result.get('data', [{}])[0].get('record_count', 0) if count_result.get('data') else 0
            
            # Get sample records
            sample_records = []
            if preview_result.get('data'):
                for i, record in enumerate(preview_result['data'][:5]):
                    formatted = {
                        'id': record.get('id'),
                        'amount': f"${abs(float(record.get('amount', 0))):.2f}",
                        'category_id': record.get('category_id'),
                        'created_at': record.get('created_at')
                    }
                    sample_records.append(formatted)
            
            # Generate human summary
            if record_count == 0:
                message = "No records match the delete criteria."
            elif record_count == 1:
                message = "1 record will be deleted."
                if sample_records:
                    amount = sample_records[0].get('amount', 'unknown')
                    message += f" This is a {amount} transaction."
            elif record_count <= 5:
                message = f"{record_count} records will be deleted."
                if sample_records:
                    amounts = [r['amount'] for r in sample_records]
                    message += f" Includes: {', '.join(amounts)}"
            else:
                message = f"{record_count} records will be deleted."
                if sample_records:
                    amounts = [r['amount'] for r in sample_records]
                    message += f" First few: {', '.join(amounts)} and {record_count - 5} more."
            
            return {
                'record_count': record_count,
                'sample_records': sample_records,
                'message': message,
                'preview_sql': preview_sql
            }
            
        except Exception as e:
            logger.warning(f"Could not generate delete preview: {e}")
            return {
                'record_count': 0,
                'sample_records': [],
                'message': "Unable to preview what will be deleted. Proceed with caution.",
                'error': str(e)
            }
    
    def _cleanup_old_pending_deletes(self, max_age_minutes: int = 10):
        """Clean up pending deletes older than max_age_minutes"""
        try:
            from datetime import datetime, timedelta
            cutoff_time = datetime.now() - timedelta(minutes=max_age_minutes)
            
            for user_id in list(self.pending_deletes.keys()):
                for confirmation_id in list(self.pending_deletes[user_id].keys()):
                    delete_info = self.pending_deletes[user_id][confirmation_id]
                    if delete_info['created_at'] < cutoff_time:
                        del self.pending_deletes[user_id][confirmation_id]
                        logger.info(f"Cleaned up expired pending delete: {confirmation_id}")
                
                # Remove empty user entries
                if not self.pending_deletes[user_id]:
                    del self.pending_deletes[user_id]
                    
        except Exception as e:
            logger.error(f"Error cleaning up pending deletes: {e}")


    def list_pending_deletes(self, user_id: int) -> Dict[str, Any]:
        """List all pending delete operations for a user"""
        try:
            if user_id not in self.pending_deletes or not self.pending_deletes[user_id]:
                return {
                    "status": "NO_PENDING",
                    "message": "No pending delete operations.",
                    "pending_count": 0
                }
            
            pending_list = []
            for conf_id, delete_info in self.pending_deletes[user_id].items():
                pending_list.append({
                    'confirmation_id': conf_id,
                    'original_query': delete_info['original_query'],
                    'preview_message': delete_info['preview']['message'],
                    'record_count': delete_info['preview']['record_count'],
                    'created_at': delete_info['created_at'].strftime('%Y-%m-%d %H:%M:%S') if hasattr(delete_info['created_at'], 'strftime') else str(delete_info['created_at'])
                })
            
            return {
                "status": "HAS_PENDING",
                "message": f"You have {len(pending_list)} pending delete operation(s).",
                "pending_count": len(pending_list),
                "pending_operations": pending_list
            }
            
        except Exception as e:
            logger.error(f"Error listing pending deletes: {e}")
            return {
                "status": "ERROR",
                "message": f"Failed to list pending deletes: {str(e)}"
            }

    def cancel_all_pending_deletes(self, user_id: int) -> Dict[str, Any]:
        """Cancel all pending delete operations for a user"""
        try:
            if user_id not in self.pending_deletes:
                return {
                    "status": "NO_PENDING",
                    "message": "No pending delete operations to cancel.",
                    "cancelled_count": 0
                }
            
            cancelled_count = len(self.pending_deletes[user_id])
            
            # Log each cancellation
            for conf_id, delete_info in self.pending_deletes[user_id].items():
                self.log_interaction(
                    user_id=user_id,
                    original_prompt=f"AUTO-CANCELLED: {delete_info['original_query']}",
                    response=f"Cancelled all pending deletes. Included confirmation ID: {conf_id}"
                )
            
            # Clear all pending deletes for this user
            del self.pending_deletes[user_id]
            
            return {
                "status": "CANCELLED",
                "message": f"Cancelled {cancelled_count} pending delete operation(s).",
                "cancelled_count": cancelled_count
            }
            
        except Exception as e:
            logger.error(f"Error cancelling all pending deletes: {e}")
            return {
                "status": "ERROR",
                "message": f"Failed to cancel pending deletes: {str(e)}"
            }


    def log_interaction(self, user_id: int, original_prompt: str, response: str):
        """Log interaction to database with proper escaping and commit"""
        try:
            # Use parameterized query
            sql_query = """
            INSERT INTO llmlogs (user_id, prompt, response) 
            VALUES (:user_id, :prompt, :response)
            """
            
            # Execute with parameters
            params = {
                'user_id': user_id,
                'prompt': original_prompt,
                'response': response
            }
            
            result = self.query_runner.execute_query_with_params(sql_query, params)
            logger.info(f"Logged interaction for user {user_id}")
            
        except Exception as e:
            logger.warning(f"Could not log interaction: {e}")
            # Try to fix sequence for duplicate key error
            if "duplicate key" in str(e) and "llmlogs_pkey" in str(e):
                self._fix_llmlogs_sequence()
    
    def _fix_llmlogs_sequence(self):
        """Fix the llmlogs sequence if it's out of sync"""
        try:
            fix_sql = """
            SELECT setval('llmlogs_id_seq1', 
                        (SELECT COALESCE(MAX(id), 0) + 1 FROM llmlogs),
                        false);
            """
            self.query_runner.execute_query(fix_sql)
            logger.info("Fixed llmlogs sequence")
        except Exception as e:
            logger.error(f"Failed to fix sequence: {e}")
    
    def get_chat_history(self, user_id: int, limit: int = 50) -> List[Dict[str, Any]]:
   
        try:
            # Use parameterized query
            sql_query = """
            SELECT id, prompt, response, timestamp 
            FROM llmlogs 
            WHERE user_id = :user_id 
            ORDER BY timestamp ASC 
            LIMIT :limit
            """
            
            params = {
                'user_id': user_id,
                'limit': limit
            }
            
            result = self.query_runner.execute_query_with_params(sql_query, params)
            
            # Format data for frontend
            history = []
            if result.get("data"):
                for row in result["data"]:
                    log_id = row[0]
                    prompt = row[1]
                    response = row[2]
                    timestamp = row[3]
                    
                    # Convert timestamp to string for JSON
                    if hasattr(timestamp, 'isoformat'):
                        timestamp_str = timestamp.isoformat()
                    else:
                        timestamp_str = str(timestamp)
                    
                    # 1. User Message
                    history.append({
                        "id": f"user_log_{log_id}",
                        "role": "user",
                        "content": prompt,
                        "timestamp": timestamp_str
                    })
                    
                    # 2. Agent Response
                    history.append({
                        "id": f"agent_log_{log_id}",
                        "role": "agent",
                        "content": response,
                        "timestamp": timestamp_str
                    })
            
            return history
            
        except Exception as e:
            logger.error(f"Could not retrieve chat history for user {user_id}: {e}")
            return []
        
        